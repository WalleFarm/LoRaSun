
#include "nwk_bsp.h"




static const u8 rf_table[][2]={  //SF,BW  无线参数表,可根据自己的需求配置,独立网络中一致即可
  11, 9,  //470.25M 
  10, 8,
  
  11, 8,  //470.75M 
  10, 7,
  
  11, 7,  //471.25M
  10, 6,
  
  11, 6,  //471.75M 
  11, 6,  
    
};

static const u8 up_table[][2]={  //SF,BW  无线参数表,可根据自己的需求配置,独立网络中一致即可
  9, 9,  
  10, 9, 
  11, 9,  
  11, 8,  
  11, 7,  
  11, 6,  

};

static const u8 down_table[][2]={  //SF,BW  无线参数表,可根据自己的需求配置,独立网络中一致即可  
  11, 9,   
  11, 8,  
  11, 7,  
  11, 6,  

};

//SX1278 建议参数表
//  11, 9,  //470.25M 
//  10, 8,
//  
//  11, 8,  //470.75M 
//  10, 7,
//  
//  11, 7,  //471.25M
//  10, 6,
//  
//  12, 7,  //471.75M 
//  11, 6,  

//SX1268 建议参数表  BW要减去3
//  11, 9,  //470.75M 
//  10, 8,
//  
//  11, 8,  //470.25M 
//  10, 7,
//  
//  12, 8,  //471.25M
//  11, 7,
//  
//  12, 7,  //471.75M 
//  12, 7, 

//LLCC68 建议参数表  BW要减去3  如果三种芯片要混用,只能用这个参数表
//  9, 9,  //470.75M 
//  8, 8,
//  
//  11, 9,  //470.25M 
//  10, 8,
//  
//  11, 8,  //471.25M
//  10, 7,
//  
//  11, 7,  //471.75M 
//  11, 7,  

/*		
================================================================================
描述 : crc16校验
输入 : 
输出 : 
================================================================================
*/ 
u16 nwk_crc16(u8 *puchMsg,u16 usDataLen)
{
  return drv_crc16(puchMsg, usDataLen);
}

/*		
================================================================================
描述 : 在一个长数组中匹配短数组
输入 : 
输出 : 
================================================================================
*/ 
u8 *nwk_find_head(u8 *full_str, u16 full_len, u8 *sub_str, u16 sub_len)
{
	int last_pos=full_len-sub_len+1;
	u16 i;
	
	if(last_pos<0)
	{
		return NULL;
	}
	for(i=0;i<last_pos;i++)
	{
		if(full_str[i]==sub_str[0])//先对比第一个字节
		{
			if( memcmp(&full_str[i], sub_str, sub_len)==0 )
			{
				return &full_str[i];
			}		
		}		
	}
	return NULL;	
}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/ 
void nwk_delay_ms(u32 dlyms)
{
  delay_ms(dlyms);
}

///*		
//================================================================================
//描述 : 
//输入 : 
//输出 : 
//================================================================================
//*/ 
//void nwk_delay_us(u32 dlyus)
//{
//  delay_us(dlyus);
//}

/*		
================================================================================
描述 : AES-CBC模式加密
输入 : 
输出 : 
================================================================================
*/ 
int nwk_aes_encrypt(u8 *in_buff, u16 in_len,u8 *out_buff, u16 out_size,u8 *passwd)
{
  return aes_encrypt_buff(in_buff, in_len, out_buff, out_size, passwd);
}

/*		
================================================================================
描述 : AES-CBC模式解密
输入 : 
输出 : 
================================================================================
*/ 
int nwk_aes_decrypt(u8 *in_buff, u16 in_len,u8 *out_buff, u16 out_size,u8 *passwd)
{
  return aes_decrypt_buff(in_buff, in_len, out_buff, out_size, passwd);
}

/*		
================================================================================
描述 : TEA数据加密函数
输入 : 
输出 : 
================================================================================
*/ 
u16 nwk_tea_encrypt(u8 *buff, u16 len, u32* key)
{
  return tea_encrypt_buff(buff, len, key);
}

/*		
================================================================================
描述 : TEA数据解密函数
输入 : 
输出 : 
================================================================================
*/
u16 nwk_tea_decrypt(u8 *buff, u16 len, u32* key)
{
  return tea_decrypt_buff(buff, len, key);
}

/*		
================================================================================
描述 : 获取RTC时间
输入 : 
输出 : 
================================================================================
*/
u32 nwk_get_rtc_counter(void)
{
  return drv_get_rtc_counter();
//	return drv_get_sec_counter();
}

/*		
================================================================================
描述 : 设置RTC时间
输入 : 
输出 : 
================================================================================
*/
void nwk_set_rtc_counter(u32 time)
{
  drv_set_rtc_counter(time);
}

/*		
================================================================================
描述 : 获取sec时间
输入 : 
输出 : 
================================================================================
*/
u32 nwk_get_sec_counter(void)
{
	return drv_get_sec_counter();
}

///*		
//================================================================================
//描述 : 存储读取
//输入 : 
//输出 : 
//================================================================================
//*/
//void nwk_eeprom_read(u8 *out_buff, u32 size)
//{
//  EEPROM_Read(200, out_buff, size);
//}

///*		
//================================================================================
//描述 : 存储设置
//输入 : 
//输出 : 
//================================================================================
//*/
//void nwk_eeprom_save(u8 *buff, u32 size)
//{
//  EEPROM_Write(200, buff, size);
//}


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


int nwk_get_rand(void)
{
  static u32 srand_num=0;
  if(srand_num==0)
  {
    srand_num=nwk_get_rtc_counter();
    srand(srand_num);
  }
  
  int rand_num=rand();
//  srand_num=rand_num;
  return rand_num;
}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/
//void nwk_get_channel(u8 chn, u8 *sf, u8 *bw)
//{
//  *sf=*bw=0;
//  if(chn<NWK_RF_CHANNEL_NUM)
//  {
//    *sf=rf_table[chn][0];
//    *bw=rf_table[chn][1];
//  }
//}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/
void nwk_get_up_channel(u8 chn, u8 *sf, u8 *bw)
{
  *sf=*bw=0;
  if(chn<NWK_UP_CHANNEL_NUM) 
  {
    *sf=up_table[chn][0];
    *bw=up_table[chn][1];
  }
}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/
void nwk_get_down_channel(u8 chn, u8 *sf, u8 *bw)
{
  *sf=*bw=0;
  if(chn<NWK_DOWN_CHANNEL_NUM) 
  {
    *sf=down_table[chn][0];
    *bw=down_table[chn][1];
  }
}


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/
u16 nwk_cacul_sniff_time(u8 sf, u8 bw)
{
	float bw_value=0.f, t_s;
	u32 tx_time=0;
	
	switch(bw)
	{
		case 0:
			bw_value=7.8;
			break;
		case 1:
			bw_value=10.4;
			break;
		case 2:
			bw_value=15.6;
			break;
		case 3:
			bw_value=20.8;
			break;
		case 4:
			bw_value=31.25;
			break;
		case 5:
			bw_value=41.6;
			break;
		case 6:
			bw_value=62.5;
			break;
		case 7:
			bw_value=125;
			break;
		case 8:
			bw_value=250;
			break;
		case 9:
			bw_value=500;
			break;
		default: return 0;	
	}
	
	if(sf<7 || sf>12)
	{
		return 0;
	}
	t_s=1.f*(1<<sf)/bw_value;
  tx_time=t_s*1;  
  return tx_time;
}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/










