#include "drv_sx1268.h"
#include "drv_uart.h"





/*		
================================================================================
描述 : 设置待机模式下振荡器类型,
输入 : RC或者XOSC
输出 : 
================================================================================
*/
void drv_sx1268_set_standby(DrvSx1268Struct *psx1268, u8 standby_mode)
{
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_STANDBY, (u8*)&standby_mode, 1);
}


/*		
================================================================================
描述 : 进入休眠模式
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_sleep(DrvSx1268Struct *psx1268)
{
  u8 value=0;
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_SLEEP, (u8*)&value, 1);
}

/*		
================================================================================
描述 : CAD初始化
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_cad_init(DrvSx1268Struct *psx1268)
{
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_CAD, NULL, 0);
}

/*		
================================================================================
描述 : 设置运行模式, FSK或LORA
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_mode(DrvSx1268Struct *psx1268, u8 mode)
{
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_PACKETTYPE, (u8*)&mode, 1);  
}

/*		
================================================================================
描述 : 设置载波频率
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_freq(DrvSx1268Struct *psx1268, u32 freq)
{
  u8 buff[4]={0};
  
  u32 freqInPllSteps = 0;
  freqInPllSteps = drv_sx1268_convert_freqinhz2pllstep( freq );
  buff[0]=freqInPllSteps>>24;
  buff[1]=freqInPllSteps>>16;
  buff[2]=freqInPllSteps>>8;
  buff[3]=freqInPllSteps;
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_RFFREQUENCY, buff, 4);  
}

/*		
================================================================================
描述 :
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_sf_bw(DrvSx1268Struct *psx1268, u8 sf, u8 bw)
{
  u8 buff[4]={0};
  buff[0]=sf;
  buff[1]=bw-3;//为了与SX1278保持一致
  buff[2]=1;//编码率
  buff[3]=true;//低速率优化
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_MODULATIONPARAMS, buff, 4); 
  
}

/*		
================================================================================
描述 :
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_pack_params(DrvSx1268Struct *psx1268)
{
  u8 buff[10]={0};
  u16 PreambleLength=8;//前导码长度
  buff[0]=PreambleLength>>8;
  buff[1]=PreambleLength;
  buff[2]=0;//可变长度数据包（显式报头）
  buff[3]=0xFF;//负载长度
  buff[4]=0x01;//CRC ON
  buff[5]=0;//标准IQ极性
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_MODULATIONPARAMS, buff, 6); 

  u8 reg_val=hal_sx1268_read_reg(&psx1268->tag_hal_sx1268, 0x0736);
  hal_sx1268_write_reg(&psx1268->tag_hal_sx1268, 0x0736, reg_val | ( 1 << 2 ) );//使用标准IQ极性是第2位置1  
}

/*		
================================================================================
描述 : DIO2设置为射频自动切换开关
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_set_dio2_switchctrl(DrvSx1268Struct *psx1268, u8 enable)
{
  u8 buff[1]={0};
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_SET_RFSWITCHMODE, buff, 1); 
}

/*		
================================================================================
描述 : 频段校准
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_calibrate_image(DrvSx1268Struct *psx1268, u32 freq)
{
    uint8_t calFreq[2];

    if( freq > 900000000 )
    {
        calFreq[0] = 0xE1;
        calFreq[1] = 0xE9;
    }
    else if( freq > 850000000 )
    {
        calFreq[0] = 0xD7;
        calFreq[1] = 0xDB;
    }
    else if( freq > 770000000 )
    {
        calFreq[0] = 0xC1;
        calFreq[1] = 0xC5;
    }
    else if( freq > 460000000 )
    {
        calFreq[0] = 0x75;
        calFreq[1] = 0x81;
    }
    else if( freq > 425000000 )
    {
        calFreq[0] = 0x6B;
        calFreq[1] = 0x6F;
    }
    hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_CALIBRATEIMAGE, calFreq, 2); 
}

/*		
================================================================================
描述 : PA输出等级
输入 : level:0~4对应10-14-17-20-22dmb
输出 : 
================================================================================
*/
void drv_sx1268_set_pa(DrvSx1268Struct *psx1268, u8 level)
{
  u8 pa_buff[5][4]={
    0x00, 0x03, 0x00, 0x01,//10dbm
    0x04, 0x06, 0x00, 0x01,//14dbm
    0x02, 0x03, 0x00, 0x01,//17dbm
    0x03, 0x05, 0x00, 0x01,//20dbm
    0x04, 0x07, 0x00, 0x01,//22dbm
  };
  if(level>4)level=4;
  
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_CALIBRATEIMAGE, &pa_buff[level][0], 4); 
}

/*		
================================================================================
描述 : 获取中断标志
输入 : 
输出 : 
================================================================================
*/
u16 drv_sx1268_get_irq_status(DrvSx1268Struct *psx1268)
{
  u8 irqStatus[2];

  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_GET_IRQSTATUS, irqStatus, 2); 
  return ( irqStatus[0] << 8 ) | irqStatus[1];  
}

/*		
================================================================================
描述 : 清理中断标志
输入 : 
输出 : 
================================================================================
*/
void drv_sx1268_clr_irq_status(DrvSx1268Struct *psx1268, u16 irq)
{
  u8 buff[2]={0};
  buff[0] = ( uint8_t )( ( ( uint16_t )irq >> 8 ) & 0x00FF );
  buff[1] = ( uint8_t )( ( uint16_t )irq & 0x00FF );  
  hal_sx1268_write_cmd(&psx1268->tag_hal_sx1268, SX1268_CLR_IRQSTATUS, buff, 2);   
}


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/
u32 drv_sx1268_convert_freqinhz2pllstep( u32 freqInHz)
{
    uint32_t stepsInt;
    uint32_t stepsFrac;

    // pllSteps = freqInHz / (SX126X_XTAL_FREQ / 2^19 )
    // Get integer and fractional parts of the frequency computed with a PLL step scaled value
    stepsInt = freqInHz / SX1268_PLL_STEP_SCALED;
    stepsFrac = freqInHz - ( stepsInt * SX1268_PLL_STEP_SCALED );
    
    // Apply the scaling factor to retrieve a frequency in Hz (+ ceiling)
    return ( stepsInt << SX1268_PLL_STEP_SHIFT_AMOUNT ) + 
           ( ( ( stepsFrac << SX1268_PLL_STEP_SHIFT_AMOUNT ) + ( SX1268_PLL_STEP_SCALED >> 1 ) ) /
             SX1268_PLL_STEP_SCALED );  
}

/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/


/*		
================================================================================
描述 : 
输入 : 
输出 : 
================================================================================
*/










